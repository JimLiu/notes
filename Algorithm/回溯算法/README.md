# 回溯算法
## 经典问题
    1. N 皇后问题
    2. 生成 K 进制串 (2 进制串)

## 基本原理
    回溯算法中, 用于解决这样一类问题: 从一个指定的集合中, 选择一个对象序列, 使该序列满足某一标准.比如 n 皇后问题: 集合就是棋盘上 n^2 个可供选择的
    位置, 序列就是这些皇后 n 个放置的位置, 标准就是任何两个皇后都不会相互威胁到对方.
    回溯算法是一种经过修改的尝试优先查找方法. 但是它是在树中查找.
    伪代码如下: (深度优先查找递归算法)

```java
void depth_first_tree_search(node v){
    node v;
    visit(v);
    for(u in v 的子节点){
        depth_first_tree_search(u);
    }
}
```
## 生成状态树
    为了解决问题, 将结果想象成一颗树.每个节点存储对应每一级的一个状态.以此类推.从根节点到叶节点, 就是一个候选答案.这棵就是生成状态树.     
    比如: 生成 2 进制串(为了方便写成如下方式, 如果写成树结构会更好)
    /null 
    |- 0
    |  |- 0
    |  |  |- 0
    |  |  |- 1
    |  |
    |  |- 1
    |     |- 0
    |     |- 1
    |- 1
       |- 0
       |  |- 0
       |  |- 1
       |
       |- 1 
          |- 0
          |- 1
    实际上, 我们在实现回溯算法的时候, 并没有创建状态空间树, 它在算法中是隐式存在的.因为我们并没有实际构建它.
 
## 回溯 backtracking
    回溯过程是指, 在确定一个节点只会引向死胡同时, 我们回退(回溯)到该节点的父节点,在下一个节点上继续查找. 如果在查找一个节点时发现, 它不可能给出答
    案, 那就说是没有希望的(nonpromising). 否则我们说是有希望的(promising). 总结一下, 回溯过程包括, 对一个状态空间树进行深度优先查找, 检查每
    个节点有没有希望, 如果没有希望, 则回溯到该节点的父节点. 这称为状态空间树的修剪(pruning, 由已访问节点组成的子树称为修剪后的状态空间树).
    
    递归算法的实现中, 是将一个无希望的节点的活动记录从活动记录中栈中弹出, 以此来完成回溯.

## 回溯的一般算法
```scala
def checknode(node v) = {
  var u: node
  if(promising(v)){         // 如果 v 满足限制条件
    if(satisfied(v)){       // 查看 v 是否有一个答案
      exposeAnswer(v)       // 给出答案
    }else{                  // 如果不满足限制条件
      for(u <- v.children){ // 遍历所有的 v 的子节点
        checknode(u)        // 递归调用.
      }
    }
  }
}
```











