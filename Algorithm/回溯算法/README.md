# 回溯算法
## 经典问题
    1. N 皇后问题
    2. 生成 K 进制串 (2 进制串)

## 基本原理
    回溯算法中, 用于解决这样一类问题: 从一个指定的集合中, 选择一个对象序列, 使该序列满足某一标准.比如 n 皇后问题: 集合就是棋盘上 n^2 个可供选择的
    位置, 序列就是这些皇后 n 个放置的位置, 标准就是任何两个皇后都不会相互威胁到对方.
    回溯算法是一种经过修改的尝试优先查找方法. 但是它是在树中查找.
    伪代码如下: (深度优先查找递归算法)

```java
void depth_first_tree_search(node v){
    node v;
    visit(v);
    for(u in v 的子节点){
        depth_first_tree_search(u);
    }
}
```
## 生成状态树
    为了解决问题, 将结果想象成一颗树.每个节点存储对应每一级的一个状态.以此类推.从根节点到叶节点, 就是一个候选答案.这棵就是生成状态树.     
    比如: 生成 2 进制串(为了方便写成如下方式, 如果写成树结构会更好)
    /null 
    |- 0
    |  |- 0
    |  |  |- 0
    |  |  |- 1
    |  |- 1
    |     |- 0
    |     |- 1
    |- 1
       |- 0
       |  |- 0
       |  |- 1
       |- 1 
          |- 0
          |- 1
## 回溯 backtracking
    回溯过程是指, 在确定一个节点只会引向死胡同时, 我们回退(回溯)到该节点的父节点,在下一个节点上继续查找.
    











